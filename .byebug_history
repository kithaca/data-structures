c
@store
n
@store
(i)
s
(i)
s
@store[i]
@store[i-1]
capacity-1
(i)
s
n
@store[0]
n
self
c
arr
n
capacity
n
c
arr
n
@count
n
s
@store
@store[0]
s
count
c
s
@store
self
c
count
(i)
c
arr
arr[-1] = 200
arr[-1]
arr
n
@store[count + i]
c
display count
c
cc
c
@store[94]
@store.length
c
display count + i
display i
c
@store
c
display count + i
display count
display i
c
(count + i)
count
c
(count + i)
count
c
count
c
count
n
count
c
s
(i < 0 && count + i < 0)
(i < 0)
i < 0
(count + i < 0)
c
n
count
(count + i >= count)
(count + i)
(count + i < 0 )
(i < 0)
display i
c
cc
c
(count + i)
s
@store[i]
display i
c
n
display i
c
(i + count)
(i)
count
(count +i)
count +i
c
display i
c
@store[-1]
(count + i)
c
n
@store[count+i]
@store[count+i)
@store[4]
(count+i)
count
@store
display i
c
cc
c
cc
c
cc
c
@store
(i < 0)
i < 0
display i
c
select { |el| el == val }.first != nil
@store
select { |el| el == val }
val
c
count
@store
c
@store
n
capacity
count
s
curr_el
@store
c
capacity
count
s
curr_el
cur_el
@store
c
@store
curr_el
c
curr_el
@store
c
curr_el
@store
c
s
curr_el
n
curr_el
@store[i]
next_el
n
display @store
display i
n
curr_el
next_el
@store
n
@store
next_el
n
c
next_el
@store[i]
@store
curr_el
next_el
n
c
@store
curr_el
next_el
n
capacity
display i
i
c
n
c
capacity
curr_el
n
s
@store
n
s
first
self
val
c
self
val
c
val
n
include?(key)
s
@store
n
s
c
display key
display count
c
s
select { |link| link.key == key}.first
select { |link| link.key == key}
self
include?(key)
s
lru_link.key
n
s
count > @max
c
display count
display key
c
key
include?(key)
s
n
s
count > @max
c
display count
cc
c
s
@store
@stoe
@store.first
s
c
@map.count
c
display key
display count
