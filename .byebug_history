c
val
n
include?(key)
s
@store
n
s
c
display key
display count
c
s
select { |link| link.key == key}.first
select { |link| link.key == key}
self
include?(key)
s
lru_link.key
n
s
count > @max
c
display count
display key
c
key
include?(key)
s
n
s
count > @max
c
display count
cc
c
s
@store
@stoe
@store.first
s
c
@map.count
c
display key
display count
count
@max
c
@map.get_link(0)
val
@map[0]
@map
@map.get_link(key)
c
@map.get_link(0)
c
@map.get_link(1)
@map.get_link(key)
@amp[key]
c
display key
c
@map.get_link(key)c
@map.get_link(key)
@map[key]
key
c
s
@prc.call(key)
@map[key]
c
display key
c
@prc
@prc.call(2)
@prc.call(0)
key
@prc.call(1)
val
c
@map.get(1)
c
@map.count
c
@map.count
c
display key
@map.count
@map.cou nt
key
c
@map
@prc.call(key)
@prc
val
c
s
n
c
cc
c
cc
c
@store
key
s
@map.get(1)
@store
@map
@map.count
@map.include?(1)
key
c
key
c
key
c
key
c
key
c
@store
@map
@map.include?(1)
key
c
@map.include?(key)
key
c
key
n
key
n
@map.include?(1)
@map
c
n
s
val
@max
count
s
self
@head
n
s
empty?
empty
n
val
key
s
@map.include?(1)
@map.get(1)
@map
s
@count
bucket(key)
s
@tail
@head
n
empty?
n
self
bucket
n
s
bucket(key)
n
s
get(key)
s
key
val
c
link
n
key
s
self.include?(key)
key
include?(key)
get(key)
self
s
n
self
s
key
n
self
s
n
self
s
key
n
self
key
s
key
list
list.include?(key)
@store
n
self
s
self
key
s
list
s
@store
s
key
@map.include?(key)
@store
@map
key
c
@store
key
c
n
@prc.call(key)
@prc
s
n
key
c
@prc.call(key)
@prc
val
n
@store
@map.include?(key)
@map
key
c
key
c
key
c
@store.include?(1)
@store
@map.last
@map.first
@map.head
self
key
@map
c
link.val
s
